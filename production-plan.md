---
title : tm_server в цикле dev-stage-prod
excerpt : План проекта tm_server по развертыванию Industrial IOT 4.0 с помощью balena на RPI4
---

Знакомство с екосистемой balena на примере [Get started with Raspberry Pi 4 and Node.js](https://www.balena.io/docs/learn/getting-started/raspberrypi4-64/nodejs/)

# Подготовка к производству

Развертывание парка удаленно подключенных устройств требует тщательного планирования.
Правильное решение должно учитывать;

* где устройства будут развернуты,
* что им нужно делать,
* как они будут обслуживаться,
* и, конечно же, доступный бюджет.

Чтобы помочь начать работу, ниже, в общих чертах описан базовый план проекта, охватывающий рекомендуемые шаги по подготовке производственного парка, а также вопросы, которые вы захотите рассмотреть в процессе.
[Эскиз проекта на GitHub](https://github.com/users/joyshmitz/projects/1)


## Этап 1: Дизайн

Устройства размещаются в шкафах телеметрии, и это как правило полевые условия, зимой холодно до -15, летом жарко до +60

Первый шаг в разработке решения - определить, как и где будут работать наши устройства. Наш вариант использования будет определять выбор *оборудования* и *операционной среды*, необходимых для успешного развертывания нашего приложения.

### Оборудование

Существует ряд SoC, способных поддерживать Linux и запускать приложения на периферии. Параметры сильно различаются по возможностям и цене, мы остановились на платформе ARM, Raspberry Pi:

Оборудование представлено двумя моделями:

* Raspberry Pi 4 Model B 8GB 32GB SD Card
* Raspberry Pi Compute Module 4 I/O Board, плата + Raspberry Pi Compute Module 4 CM4008008

Питание 5V, и 12V

* RPI 4 Model B - Mean Well MDR-20-5 `IN: 110-240V AC 0,55A, OUT: 5V 3.0A`
* Raspberry Pi Compute Module 4 I/O Board - Mean Well NDR-120-12 `IN: 110-240VAC, 2,6A, OUT: 12V 10A`

### Рабочая среда

Используем подход [balenaBlocks](https://www.balena.io/docs/learn/more/examples/balenablocks/#balenablocks-built-for-balenacloud)

![balenaBloks](https://assets.balena.io/blog-common/archive/2020/12/blocks_Blog.png)

balenaBlocks - это предварительно созданные образы контейнеров, которые разработчики могут добавлять в свои многоконтейнерные приложения для обеспечения полезной функциональности. Их цель - уменьшить трение при создании приложений IoT, которые обеспечивают быстрое прототипирование и разработку. Эти интеллектуальные функциональные блоки созданы для работы с основами и позволяют разработчикам сосредоточиться на решении сложных проблем. Вы можете узнать больше о balenaBlocks в [блоге компании balena](https://www.balena.io/blog/introducing-balenablocks-jumpstart-your-iot-app-development/)

[Блок шаблонов, позволяющий начать создавать balenabloks для проектов и флотов](https://github.com/balenablocks/template)

Особенности

Пример balenablock: Чтобы начать создавать свои собственные balenablocks
Авто публикация сборок архитектур: предварительная сборка образов для [кастомных архитектур](https://www.balena.io/docs/reference/base-images/devicetypes/#machine-names-and-architectures) с помощью действий GitHub.
Самодокументирование: на основе выражений для nodejs блоков, автоматически генерируется [swagger.io](https://swagger.io/) документация.

#### Комментарии к Рабочей среде

Одна из проблем при создании приложений для распределенных парков - согласование среды разработки с операционной средой, работающей на устройствах.

balena.io решает эти проблемы, используя balenaOS, базовую ОС с легким, совместимым с Docker движком контейнеров, [balenaEngine](https://www.balena.io/engine). С помощью контейнеров можно разработать свое приложение наиболее удобным для нас способом, а затем запустить эту среду на устройстве, не беспокоясь о базовой аппаратной поддержке. Любые зависимости, такие как библиотеки и среды выполнения, уже будут упакованы в контейнер.

Контейнеры также упрощают удаленное обновление. Новый выпуск можно загрузить, проверить и запустить, пока ОС хоста поддерживает сетевое соединение.

Следует учитывать, хотим ли мы использовать один контейнер или несколько. У каждого подхода есть свои преимущества. Управлять одним контейнером проще всего - нет необходимости беспокоиться о межконтейнерном взаимодействии или конфликте ресурсов. Но это означает, что нам нужно будет управлять всеми компонентами нашего приложения в одном месте.

Использование нескольких контейнеров позволяет разделить компоненты и даже группы разработчиков. Разделение нашего приложения на контейнерные службы может, например, позволить одной команде работать над внешним интерфейсом нашего приложения, в то время как другая работает над внутренним интерфейсом, при этом каждая команда отправляет обновления независимо. Разные команды могут даже использовать совершенно разные операционные среды: одна команда может использовать Debian, а другая - Fedora. Это требует некоторой координации, так как нужно будет назначить ресурсы, необходимые каждому контейнеру, через что-то вроде файла [Docker Compose](https://docs.docker.com/compose/overview/).

## Этап 2: Прототип

На этапе прототипирования важно разрабатывать на том же устройстве, которое мы будете использовать в своем производственном парке. Может возникнуть соблазн использовать виртуальное устройство, но у этого подхода есть ряд недостатков. С виртуальными устройствами, как правило, труднее работать, чем с физическими устройствами, и они часто намного медленнее. Придерживаясь одного и того же устройства на этапах прототипа, пилотного проекта и производства, мы снизите риск любых неожиданных сбоев на этом пути.

На этапе прототипирования начинают действовать некоторые из ориентированных на разработчиков функций платформы balena, предлагая несколько способов доступа к ОС хоста и контейнерам, работающим на нашем устройстве:

### Образы для разработки Development images

При разработке нового приложения нам следует подумать об использовании [образа](https://www.balena.io/docs/reference/OS/overview/2.x/#development-vs-production-images) для [разработки](https://www.balena.io/docs/reference/OS/overview/2.x/#development-vs-production-images) balenaOS. Эти образы имеют ряд функций, которые по соображениям безопасности отсутствуют в производственных версиях balenaOS. К ним относятся:

* Passwordless SSH access to the host OS
* Access to the Docker socket
* Serial and console logging and interactive login
* Local mode functionality

#### Базовые изображения Balena

* 6 архитектур
* Множество дистрибутивов
* Несколько языковых стеков
* run and build  многоступенчатая ​​сборка.
* cross-build функционал для сборки контейнеров ARM на x86.
* Cценарий установки пакетов, `install_packages` вдохновленный minideb.

[Обзор функций, описание](https://www.balena.io/docs/reference/base-images/base-images/)

[balenalib](https://hub.docker.com/u/balenalib/) это центральный дом для 26000+ образов Docker, ориентированных на IoT, созданных специально для balenaCloud и balenaOS . Этот набор образов дает возможность быстро и легко приступить к работе, но при этом дает возможность развертывать тонкие защищенные образы на периферии, когда вы переходите к производственной среде.

### Локальный режим

[Локальный режим](https://www.balena.io/docs/learn/develop/local-mode) дает нам возможность создавать и развертывать на устройстве в локальной сети без использования облачного конструктора balena. Это позволяет очень быстро выполнять итерацию и тестировать функциональность - во многих случаях, таких как изменения конфигурации или изменения, внесенные в код на интерпретируемом языке, обновления могут быть развернуты, вообще не требуя сборки. Локальное развертывание позволяет напрямую отразить вашу среду разработки на тестовом устройстве.

### Связь

Связь основана на Плате расширения Raspberry Pi LTE Module HAT.

`SIM7600G-H 4G/3G/2G/GSM/GPRS/GNSS HAT for Raspberry Pi` - это модуль связи и позиционирования GNSS 4G/3G/2G, который поддерживает LTE CAT4 до 150 Мбит/с для передачи данных по входящей линии связи. Модуль имеет довольно низкое энергопотребление. [Информация для разработчиков, демонстрационные коды, схемы, таблицы данных и т. д.](http://www.waveshare.com/wiki/SIM7600G-H_4G_HAT)

Вот базовые настройки для vodafone_UA, которые необходимо добавить для конфигурации сотовой связи, создав файл подключения `cellular` и добавить его в директорию `/resin-boot/system-connections` в загруженном `.img` файле balenaOS

создайте файл cellular

```bash
[connection]
id=cellular
type=gsm
autoconnect=true

[gsm]
apn=staticip
number=
password=
username=

[serial]
baud=115200

[ipv4]
method=auto

[ipv6]
addr-gen-mode=stable-privacy
method=auto
```

[здесь весь раздел network](https://www.balena.io/docs/reference/OS/network/2.x/)

[здесь настройка сотового соединения от balena](https://www.balena.io/docs/reference/OS/network/2.x/#cellular-modem-setup)

[здесь изменение сетевых настроек во время выполнения](https://www.balena.io/docs/reference/OS/network/2.x/#changing-the-network-at-runtime)

Во время создания прототипа мы должны начать думать о том, как устройства будут подключены при развертывании в реальном мире. Если есть возможность предварительно сконфигурировать сетевые настройки или сделать все с помощью DHCP, это легко. Но для большинства устройств потребуется настройка на месте.

balena предоставляет возможность настраивать сеть изнутри контейнеров и предоставляет множество функций, упрощающих эту задачу. Одним из примеров является проект [wifi-connect](https://github.com/balena-os/wifi-connect), который позволяет устройству создавать собственную точку доступа Wi-Fi, к которой пользователи могут подключаться для настройки правильных учетных данных. [API-интерфейс](https://www.balena.io/docs/reference/supervisor/supervisor-api/#patch-v1-device-host-config) balena [supervisor API](https://www.balena.io/docs/reference/supervisor/supervisor-api/#patch-v1-device-host-config) также позволяет настраивать более сложные сетевые параметры, включая конфигурацию имени хоста и прокси.

### Несколько разработчиков

На этапе создания прототипа возможно разрешить нескольким разработчикам совместно использовать ресурсы. С помощью balena мы можете добавить нескольких разработчиков в качестве [сотрудников](https://www.balena.io/docs/learn/manage/account/#fleet-members) в парк, давая им возможность управлять устройствами парка и отправлять обновления кода.

## Этап 3: Пилот

После того, как разработка нашего приложения в основном будет завершена, важно провести еще несколько реальных испытаний. balena предоставляет функциональные возможности, которые также упрощают эту задачу, предоставляя инструменты, которые помогут нам перейти от этапа прототипа к полноценной производственной среде:

### Производственные изображения

На этом этапе имеет смысл перейти от образов balenaOS для разработки к полным производственным образам, гарантируя, что наше приложение по-прежнему работает должным образом без полного доступа к локальной консоли. И мы по-прежнему можем [получить доступ ssh](https://www.balena.io/docs/learn/manage/ssh-access) к ОС и контейнерам хоста через панель управления balena и интерфейс командной строки, но рабочий образ balenaOS закроет все открытые входящие порты. .

Для пользователей производственного и корпоративного планов, которым требуется стабильный поддерживаемый выпуск, следует выбрать [ESR-версия](https://www.balena.io/docs/reference/OS/extended-support-release) ОС хоста. Версия ESR гарантирует, что нам нужно будет обновлять хост-ОС на устройствах не чаще двух раз в год, чтобы убедиться, что мы используем поддерживаемую версию. мы можем просмотреть устройства с ESR-версиями ОС хоста [здесь](https://www.balena.io/docs/reference/OS/extended-support-release#supported-devices).

### Тест вне лаборатории

Тестирование вне лаборатории поможет нам увидеть, как наше устройство ведет себя в сетях, которые мы не полностью контролируем. В идеале это должно быть сделано в среде, которая имитирует то, где будут находиться наши устройства, когда они находятся в производстве, но при этом, по крайней мере, в некоторой степени доступности.

### Сбор журналов

Очень важно, чтобы мы могли получать журналы и телеметрию со своих устройств, когда они находятся вне лаборатории. Мы можем использовать функцию ведения журнала консоли, представленную на панели управления balena, чтобы читать журналы приложений.

Если наше приложение генерирует достаточно данных журналов, метрик, что нам нужна аналитическая платформа, чтобы разобраться во всем, рассмотрите возможность [добавления агента сбора журналов](https://balena.io/blog/how-to-create-a-custom-logging-system-for-longer-log-retention/) в свои контейнеры, как и в любой другой среде.

### Тестирование при обновлении

Обязательно протестируем все возможности обновления, которые мы можете сделать, прежде чем наши устройства станут недоступными в дикой среде. Как для выпуска, так и для обновлений ОС balena включает ряд функций, чтобы убедиться, что процесс обновления не влияет на нашу способность подключаться к нашим устройствам и восстанавливать функциональность, из задач, мы понять факторы, которые могут повлиять на процесс обновления.

В частности, думая о тестировании проверить приборы на:

* потеря мощности во время обновления
* потеря сети при обновлении
* отправка нового обновления, пока выполняется другое

Понимание того, как наши устройства справляются с неблагоприятными условиями, позволяет быть уверенным в способности нашего парка своевременно получать обновления.

## Этап 4: Производство

Теперь, когда наше тестирование подходит к концу, пришло время представить наши устройства целым флотом! На этом этапе мы перейдем от перспективы, в первую очередь ориентированной на разработку, к перспективе, в первую очередь, ориентированной на операции, по крайней мере, для текущей версии нашего приложения. Конечно, мы можете продолжить разработку следующей версии, зная, что мы можете безопасно развернуть обновления для своего парка в любой момент с помощью balena

### Предварительная загрузка образов и предварительная регистрация устройств

Хотя устройство само подготовится и загрузит наш последний выпуск, как только оно будет включено и подключено к Интернету, это может быть не совсем тем опытом, который мы хотим, чтобы наши пользователи получали. Было бы неплохо иметь что-то, что работает сразу, вместо того, чтобы ждать завершения потенциально медленной загрузки.

К счастью, мы можем [предварительно загрузить](https://www.balena.io/docs/reference/cli/#preload-image) свой релиз в образ. Затем, когда этот образ будет записан на наши устройства на производстве, он будет иметь уже установленную и готовую версию. Любые обновления, внесенные в автопарк после процесса предварительной загрузки, будут загружены и применены, когда устройство будет подключено к сети, поэтому нам не нужно беспокоиться об устройствах, которые находились на складе или на полках магазинов.

В ситуациях, когда нам необходимо зарегистрировать свои устройства до того, как они будут включено и подключены к сети, мы можем [предварительно зарегистрировать](https://www.balena.io/docs/reference/cli/#device-register-fleet) их. Предварительная регистрация устройства позволяет создавать индивидуально зарегистрированные устройства в парке, что чрезвычайно полезно в таких ситуациях, как производство, где устройство может требовать отслеживания, поскольку конкретный UUID устройства затем может быть связан с конкретным заказом клиента.

Дополнительную информацию о предварительной загрузке образов и предварительной регистрации устройств можно найти в [Расширенный мастер-класс CLI](https://www.balena.io/docs/learn/more/masterclasses/advanced-cli/#5-preloading-and-preregistering) или в [документации по интерфейсу CLI](https://www.balena.io/docs/reference/cli).

### Канареечное развертывание

При обновлении программного обеспечения на производственных устройствах имеет смысл проявить осторожность и начать с нескольких устройств, чтобы убедиться, что может пойти не так. Обычная практика - начать с нескольких «канареечных» устройств, а затем постепенно развернуть обновление на все большее и большее количество устройств.

API balena включает функции, которые позволяют [детальный контроль обновления](https://github.com/balenalabs/staged-releases). С помощью этих конечных точек мы можем отключить автоматические обновления выпусков, установить целевой выпуск для всего парка или установить целевые выпуски для определенного подмножества устройств. Функции [тегов устройств](https://www.balena.io/docs/learn/manage/filters-tags/#device-tags) и [фильтров](https://www.balena.io/docs/learn/manage/filters-tags/#device-filters) позволяют легко назначать группы устройств определенным этапам развертывания.

## Дополнительные сведения

Для получения дополнительной информации об общих анти-шаблонах см. [Анти-шаблоны, или как взломать устройства](https://www.balena.io/docs/learn/more/anti-patterns).

[engine-link](https://www.balena.io/engine/?)\
[docker-compose]:<https://docs.docker.com/compose/overview/>\
[dev-vs-prod]:/reference/OS/overview/2.x/#development-vs-production-images\
[local-mode]:/learn/develop/local-mode\
[wifi-connect](https://github.com/balena-os/wifi-connect)\
[supervisor-api]:/reference/supervisor/supervisor-api/#patch-v1-device-host-config
[collaborators]:/learn/manage/account/#fleet-members\
[ssh]:/learn/manage/ssh-access\
[custom-logging]:{{ $links.blogSiteUrl }}/how-to-create-a-custom-logging-system-for-longer-log-retention/\
[cli]:/reference/cli\
[preload]:/reference/cli/#preload-image\
[preregister]:/reference/cli/#device-register-fleet\
[staged-releases]:{{ $links.githubLabs }}/staged-releases\
[tags]:/learn/manage/filters-tags/#device-tags\
[esr-devices]:/reference/OS/extended-support-release#supported-devices\
[esr]:/reference/OS/extended-support-release\
[filters]:/learn/manage/filters-tags/#device-filters\
[anti-patterns]:/learn/more/anti-patterns\
[cli-advanced-masterclass]:/learn/more/masterclasses/advanced-cli/#5-preloading-and-preregistering\
